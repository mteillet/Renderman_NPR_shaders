/*
# ------------------------------------------------------------------------------
#
# Copyright (c) 1986-2018 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# ------------------------------------------------------------------------------
*/

#ifndef RixIntegrator_h
#define RixIntegrator_h

#include <math.h>             // for sqrtf
#include <algorithm>          // for max
#include <cassert>            // for assert
#include <cstddef>            // for size_t
#include "RixBxdfLobe.h"      // for RixBXLobeSampled, etc
#include "RixInterfaces.h"    // for RixContext
#include "RixShading.h"       // for RixShadingContext, etc
#include "RixShadingUtils.h"  // for RixIsFinite
#include "prmanapi.h"         // for PRMANEXPORT, PRMAN_INLINE
#include "ri.h"               // for RtNormal3, Dot, RtPoint3, etc

class RixLPE;
class RixLPEState;
class RixLightingServices;
class RixRNG;
class RixVolumeServices;

typedef unsigned int      RixChannelId;
static const RixChannelId k_InvalidChannelId = 2147483647;

/// Note that the same channel name may appear multiple times within a list of `RixDisplayChannels`.
/// This may be caused by either the "string source" parameter to DisplayChannel or the particular
/// AOV being output multiple times.
///
/// For `RixDisplayServices` and `RixSampleFilterContext`, a single id value from any matching entry
/// (e.g., the first) will suffice to affect all outputs. For `RixDisplayFilterContext`, you
/// probably want to filter using the id values from *all* matching entries since each corresponds
/// to a particular output.
struct RixDisplayChannel
{
    RixChannelId id;
    enum ChannelStyle
    {
        k_ChannelName,
        k_ChannelExpression
    } style;
    enum ChannelType
    {
        k_FloatChannel,
        k_RGBChannel,
        k_PointChannel,
        k_NormalChannel,
        k_IntegerChannel
    } type;
    RtUString channel;
};

/// Multiple methods of `RixDisplayServices` require similar parameters:
/// - the id of the channel we want to write/splat a value to. This id is usually obtained by
///   introspecting the list of `RixDisplayChannel` objects that can be retrieved from the
///   `RixIntegratorEnvironment` interface. This list can also be retrived by calling the method
///   `GetDisplayChannels()`.
/// - an integrator context index. This is the index of the primary ray associated with the sample.
///   When looping over points in a `RixShadingContext`, this should be `sCtx.integratorCtxIndex[i]`
///
/// Most methods have two versions, differing only by the type of the provided value: float or
/// color.
class RixDisplayServices
{
public:
    /// Accumulates a value into a given display channel for a given path sample.
    /// This is accumulative; it may be called at each vertex along a light path to sum radiance
    /// thruput, for example.
    ///
    /// Note: `RixPattern` plug-ins should only write to display services during scatter queries.
    /// Users can check the shading context shading mode for `k_RixSCScatterQuery`.
    ///
    /// \param[in] id Id of the channel to write to.
    /// \param[in] iCtxIndex Integrator context index.
    /// \param[in] value The value to be splat.
    /// \return true on success (i.e. if channel exists for the camera currently being processed).
    //
    virtual bool Splat(RixChannelId id, int iCtxIndex, float const value) = 0;
    /// The color version of `RixDisplayServices::Splat(RixChannelId, int, float)`.
    virtual bool Splat(RixChannelId id, int iCtxIndex, RtColorRGB const value) = 0;

    /// The multi-channel version of `Splat()`, taking a list of channels to accumulate to. The same
    /// value will be accumulated into each channel.
    ///
    /// \param nChans Number of channels ids.
    /// \param ids Ids of the channels to write to.
    /// \param[in] iCtxIndex Integrator context index.
    /// \param[in] value The value to be splat.
    ///
    /// \return true on success (i.e. if *all* channel exists for the camera currently being
    /// processed).
    ///
    virtual bool SplatMulti(
        int nChans, RixChannelId const* ids, int iCtxIndex, float const value) = 0;
    /// The color version of `RixDisplayServices::SplatMulti(int, RixChannelId*, int, float)`.
    virtual bool SplatMulti(
        int nChans, RixChannelId const* id, int iCtxIndex, RtColorRGB const value) = 0;

    /// `Write()` is similar to `Splat()`, except that it overwrites the existing value instead of
    /// accumulating. This can be useful for AOVs that do not sum linearly.
    ///
    /// The last write into the given channel will be the one that gets filtered into the pixel for
    /// this particular sample. It is up to the user to manage their shader networks to avoid
    /// plugins fighting over the value.
    ///
    /// \param[in] id Id of the channel to write to.
    /// \param[in] iCtxIndex Integrator context index.
    /// \param[in] value The value to be written.
    ///
    /// \return true on success (i.e. if channel exists for the camera currently being processed).
    ///
    virtual bool Write(RixChannelId id, int iCtxIndex, float const value) = 0;
    /// The color version of `RixDisplayServices::Write(int, RixChannelId, float)`.
    virtual bool Write(RixChannelId id, int iCtxIndex, RtColorRGB const value) = 0;
    /// The integer version of `RixDisplayServices::Write(int, RixChannelId, float)`.
    virtual bool Write(RixChannelId id, int iCtxIndex, int const value) = 0;

    /// Overwrites the existing hit distance and information. When using deep outputs, this must be
    /// called during volume integration for them to be correct.
    ///
    /// Only one update can be saved per sample, so only the last call to `WriteDistance()` for
    /// a given sample has an effect. Use `AddSample()` with this if you'd like to have distinct
    /// samples at different distances.
    ///
    /// \param[in] iCtxIndex Integrator context index.
    ///
    /// \param [in] distance This is not the distance to the outer envelope, but to a volume
    /// scattering or absorption event or to a non-volume object intersecting the volume.
    ///
    /// \param[in] isVolume Indicates if writing distance for a volume scattering event or not.
    ///
    /// \param[in] sCtx The shading context associated with the point for which we are writing the
    /// distance.  This is necessary for `RixSampleFilter::GetAttribute()` to work properly.
    ///
    virtual void WriteDistance(
        int const                iCtxIndex,
        float const              distance,
        bool const               isVolume = true,
        RixShadingContext const* sCtx     = nullptr) = 0;

    /// Overwrites the current opacity value into the sample, which will be pixel-filtered and
    /// blended to create the pixel alpha.
    ///
    /// \param[in] id Id of the channel to write to.
    /// \param[in] iCtxIndex Integrator context index.
    /// \param[in] opacity The value to be written.
    ///
    virtual void WriteOpacity(RixChannelId id, int iCtxIndex, float const value) = 0;
    virtual void WriteOpacity(RixChannelId id, int iCtxIndex, RtColorRGB& value) = 0;

    /// Accumulates a given opacity value into the sample, which will be pixel-filtered and blended
    /// to create the pixel alpha.
    ///
    /// \param[in] id Id of the channel to write to.
    /// \param[in] iCtxIndex Integrator context index.
    /// \param[in] opacity The value to be written.
    ///
    virtual void SplatOpacity(RixChannelId id, int iCtxIndex, float const opacity) = 0;
    virtual void SplatOpacity(RixChannelId id, int iCtxIndex, RtColorRGB& opacity) = 0;

    /// Creates and adds a new sample. This new sample will be located at the same screen position
    /// as the given sample. However, it may be assigned different values and hit distances. Use
    /// this to produce better deep images from transparency and volumes. The returned value can be
    /// used as the `iCtxIndex` for the new sample in other calls or to add further samples.
    ///
    /// Note: if there is anything in front of this new sample, the integrator is still responsible
    /// for attenuating any color and opacity splatted into it.
    ///
    /// \param[in] iCtxIndex Integrator context index of the original sample.
    ///
    /// \return a new integrator context index that must be used when calling `Write()` or `Splat()`
    /// methods for this additional sample.
    ///
    virtual int AddSample(int iCtxIndex) = 0;

    /// Gets a list of available display channels. These are normally provided to the integrator via
    /// the integration environment for it to inspect during startup. However, we provide access
    /// here during runtime for more dynamic applications such as patterns and bxdfs which would
    /// like to do "writeaov()"-like things.
    ///
    /// \param[out] numDisplays Number of displays returned.
    ///
    /// \param[out] displays List of displays. Array of size `numDisplays`.
    ///
    virtual void GetDisplayChannels(int* numDisplays, RixDisplayChannel const** displays) = 0;

    /// Cancels the results of any calls made to `Splat()`, `SplatMulti()`, and `Write()` during
    /// this invocation of the integrator's `Integrate()` or `IntegrateRays()` method. This may be
    /// useful if an integrator produces poor estimates during a warmup period.
    ///
    /// \param[in] redo If true, the renderer will retry the current integration with the same
    /// inputs. Optional.
    ///
    virtual void DiscardIteration(bool redo = false) = 0;

protected:
    virtual ~RixDisplayServices() {}
};

struct PRMAN_ALIGNED_16 RtRayGeometry
{
    enum RayType
    {
        k_rtInvalid      = 0,
        k_rtCamera       = 1, /* primary visibility ray from a camera */
        k_rtLight        = 2, /* photon ray directly from a light source */
        k_rtTransmission = 3, /* shadow ray */
        k_rtDirectlight  = 4, /* directlighting ray */
        k_rtIndirect     = 5, /* indirect ray */
        k_rtNumRayTypes  = 6
    };
    
    RtPoint3  origin;        /// Ray origin.
    float     originRadius;  /// Radius of ray at its origin.
    RtVector3 direction;     /// Ray direction.

    float raySpread;  /// How much the ray radius changes for each unit the ray travels. Use as is
                      /// to get tex/env filter radii. Multiply by 2 to get footprints and tex/env
                      /// filter diameters. Values range between 0 and 1 (where 1 corresponds to an
                      /// angle of 45 degrees).
    float minDist;    /// Minimum hit distance. Used only for primary rays.
    float maxDist;    /// Maximum hit distance.
    float time;       /// Shutter-normalized time of ray launch.

    uint16_t              raytype;       /// See RayType for possible values.
    RixBXLobeSampled      lobeSampled;   /// Characteristics of the BxDF lobe this ray samples.
    RixShadingContext::Id shadingCtxId;  /// Shading context unique identifier.
    int16_t               integratorCtxIndex;  /// Associated primary ray index.
    uint16_t              shadingCtxIndex;     /// Index into the lauching shading context.
    uint16_t              rayId;               /// User-provided index in the ray bundle.
    RixLPEState*          lpeState;            /// A pointer to the LPE state for this ray launch.

    uint32_t private0[5];    /// Data for internal use.
    float opacityThreshold;  /// This value is updated on each presence hit, whenever a surface with
                             /// presence is hit. The presence value will be compared against this
                             /// threshold to decide if it is a hit or a miss.
    mutable uint16_t hitId;  /// Internal hit id, zero means 'no hit.'
    uint16_t         flags;  /// Flags for internal use.

    /// Wavelength associated with the ray. See `EncodeWavelength()` and `DecodeWavelength()`
    /// methods. This quantity is then available on hits by querying the `k_wavelength` built-in
    /// primvar with `RixShadingContext::GetBuiltinVar()`.
    uint16_t wavelength;

    /// `InitOrigination()` should be called after the ray geometry has been setup for calls to
    /// `GetNearestHits()`. In addition to setting the origination context, we analyze the
    /// combination of `lobeSampled` and `Nn` to determine whether a transmit event was a nominal
    /// enter or exit. Origination state allows rays to be back-tracked to the original shading
    /// context for recovery of ray-path information.
    ///
    /// \param[in] sCtx Shading context containing the shading point that launched this ray.
    ///
    /// \param[in] Ngn Geometric normal at the shading point that launched this ray.
    ///
    /// \param[in] _shadingCtxIndex Index of the shading point in the shading context.
    ///
    void InitOrigination(RixShadingContext const* sCtx, RtNormal3 const* Ngn, int _shadingCtxIndex)
    {
        this->shadingCtxId       = sCtx->shadingCtxId;
        this->shadingCtxIndex    = _shadingCtxIndex;
        this->integratorCtxIndex = sCtx->integratorCtxIndex[_shadingCtxIndex];
        if (this->lobeSampled.GetTransmit())
        {
            bool const entering = Dot(Ngn[_shadingCtxIndex], this->direction) <= 0.f;
            this->lobeSampled.SetEntering(entering);
        }
    }

    /// `InitTransmission()` is analogous to `InitOrigination()` but should be used for transmission
    /// rays. All transmission 'events' are transmit events and `lobeSampled` is ill-defined (since
    /// lights are responsible for producing most transmission rays).
    ///
    /// \param[in] sCtx Shading context containing the shading point that launched this ray.
    ///
    /// \param[in] _shadingCtxIndex Index of the shading point in the shading context.
    ///
    void InitTransmitOrigination(RixShadingContext const* sCtx, int _shadingCtxIndex)
    {
        this->shadingCtxId       = sCtx->shadingCtxId;
        this->shadingCtxIndex    = _shadingCtxIndex;
        this->integratorCtxIndex = sCtx->integratorCtxIndex[_shadingCtxIndex];
        this->lobeSampled.Set(
            true,   // discrete
            false,  // specular
            false,  // transmit, not reflect
            false,  // scattering
            false,  // not user
            0,      // lpeid
            0       // lobeid (unused)
        );
        this->lobeSampled.SetEntering(true);
    }

    /// Computes ray spread for given reflection/transmission type, pdf, and surface curvature,
    /// using two approaches:
    /// 1. Ray spread based on roughness (pdf). The ray spread from a flat rough surface depends on
    /// roughness: the higher roughness the lower the pdf in a given direction; here we map the pdf
    /// to a ray spread using a heuristic mapping.
    /// 2. Ray spread based on surface curvature. The ray spread for reflection from a curved smooth
    /// surface is simple to compute using Igehy's formula.
    ///
    /// We set the overall ray spread to the max of these two. (For rough curved surfaces a better
    /// answer might be larger than the max -- perhaps the sum? -- but it's not 100% clear what the
    /// optimal combined value should be.)
    ///
    /// \param[in] lobe Used to determine if we are dealing with a reflection or transmission event.
    ///
    /// \param[in] rayOriginRadius Incident ray radius at ray origin.
    ///
    /// \param[in] rayOriginSpread Incident ray spread at ray origin.
    ///
    /// \param[in] curvature Local surface curvature.
    ///
    /// \param[in] fPdf Pdf associated with the ray direction.
    ///
    /// \param[in] lightPath Indicates if the rays is part of a light path or not. Optional.
    ///
    void SetRaySpread(
        RixBXLobeSampled lobe,
        float            rayOriginRadius,
        float            rayOriginSpread,
        float            curvature,
        float            fPdf,
        bool             lightPath = false)
    {
        float pdfSpread = 0.0f;
        float newSpread;

        // Compute ray spread based on pdf (and hence surface roughness). If Dirac delta, don't use
        // pdf -- it is 1.0 by convention.
        if (!lightPath && lobe.GetSolidAngle() && fPdf > 0.0f)
        {
            // Inverse square root of pdf is a heuristic that seems to work.
            assert(fPdf > 0.0f);  // Avoid division by 0 (fPdf=inf is okay here).
            pdfSpread = 0.125f / sqrtf(fPdf);
            assert(RixIsFinite(pdfSpread));
        }

        // Compute ray spread based on surface curvature.
        if (lobe.GetReflect())
        {
            // Treat this as reflection:
            // - `k_RixBXReflectSpecular`
            // - `k_RixBXReflectGlossy`
            // - `k_RixBXReflectDiffuse`

            // Spread for specular reflection: The new ray spread is the incident ray spread plus
            // change induced by local curvature. The factor of 2 comes from differentiating the
            // formula for mirror reflection direction -- see [Igehy99].
            // Note that we clamp the spread so it doesn't become negative for highly negative
            // curvature, for example a concave mirror.
            float curvatureSpread = rayOriginSpread + 2.0f * curvature * rayOriginRadius;
            newSpread             = std::max(curvatureSpread, pdfSpread);
        }
        else if (lobe.GetTransmit())
        {
            // Treat this as refraction:
            // - `k_RixBXTransmitSpecular`
            // - `k_RixBXTransmitGlossy`

            // Spread for specular transmission -- simpler than [Igehy99] since we only need spread
            // amount, not differential direction vector:
            // - newSpread = eta * raySpread - (1.0f - eta) * curvature * rayOriginRadius;
            //
            // This can give negative spread and focusing of the ray, with the width of the ray
            // increasing beyond the focus distance. This is all good and fine, but we skip this
            // effect for now. For now: simply copy parent ray spread to avoid having to deal with
            // ior vs. 1/ior
            newSpread = std::max(rayOriginSpread, pdfSpread);

            // - `k_RixBXTransmitDiffuse`

            // Use very conservative spread for diffuse reflection and transmission: same as for
            // specular/glossy reflection.
            // (Could do better if we know PixelSamples and diffusemultfactor: compute ray solid
            // angle = 2pi / (pixsam*diffmultfac)
        }
        else
        {
            // We have no idea what this ray is, let's use the provided ray spread.
            newSpread = rayOriginSpread;
        }

        // Disallow |newSpread| > 1 or newSpread == nan
        if (!(newSpread <= 1.0f)) newSpread = 1.0f;
        if (newSpread < -1.0f) newSpread = -1.0f;
        assert(-1.0f <= newSpread && newSpread <= 1.0f);

        this->raySpread = newSpread;
    }

    /// Converts a `wavelenght` (in nanometers) to a compact 16 bits representation of it.
    /// In both units 0 means "full spectrum", meaning no wavelength is defined.
    ///
    /// \param[in] wavelength A wavelength in nanometers.
    ///
    /// \return a 16-bits encoded wavelength.
    ///
    static PRMAN_INLINE uint16_t EncodeWavelength(float wavelength)
    {
        return wavelength != 0.0f ?
                   (int((wavelength - 380.0f) * (65534.0f / (780.0f - 380.0f)) + 0.5f) + 1) :
                   0;
    }

    /// Converts from encoded 16 bits representation of wavelength to nanometers
    /// In both units 0 means "full spectrum", meaning no wavelength is defined.
    ///
    /// \param[in] encodedWavelength A 16-bits encoded wavelength
    ///
    /// \return the wavelength, in nanometers.
    ///
    static PRMAN_INLINE float DecodeWavelength(uint16_t encodedWavelength)
    {
        return encodedWavelength != 0 ?
                   (float(encodedWavelength - 1) * ((780.0f - 380.0f) / 65534.0f) + 380.0f) :
                   0.0f;
    }
};

struct RtHitPoint
{
    RtPoint3  P;           /// Hit position.
    RtNormal3 Ng;          /// Geometric normal on hit.
    float     dist;        /// Distance to hit point. 0 means 'no hit'.
    RtPoint2  uv;          /// (u,v) coordinates of the hit.
    float     filterSize;  /// Used for texture filtering.
    float     mpSize;      /// Used for ray-tracing bias calculation.
};

/// This class allows integrators to instrospect the rendering environment. An object of this type
/// is also provided to `RixIntegrator::RenderBegin()`, allowing the integrators to communicate some
/// requirements back to the renderer.
class RixIntegratorEnvironment
{
public:
    /// Indicates the sampling modes supported by the integrator.
    enum SamplingModes
    {
        k_Invalid     = 0,
        k_Fixed       = 1,
        k_Adaptive    = 2,
        k_Incremental = 4,

        k_AllModes = (k_Fixed | k_Adaptive | k_Incremental)
    };

    /// Indicates the lighting modes supported by the integrator.
    enum LightingModes
    {
        k_UnidirectionalLighting = 0,
        k_BidirectionalLighting  = 1
    };

    RixIntegratorEnvironment()
        : m_version(2),
          maxIntegrateSize(1024),
          maxShadingCtxSize(1024),
          supportedSamplingModes(k_AllModes),
          lightingRequirements(k_UnidirectionalLighting),
          numDisplays(0),
          displays(0),
          wantsEmptyIntegrate(false),
          wantsIncrementBarrier(false),
          numRaysPerIncrement(-1),
          numIncrements(0),
          numBootstrapIncrements(0),
          lobesWanted(k_RixBXTraitsAllLobe),
          cameraMediumIOR(1.f),
          cameraMediumPriority(0),
          wantsTransmission(false),
          usesLightingServices(true)
    {}

    /// Returns the first display channel with the corresponding name.
    /// NOTE: This is probably not what you want to use for `RixDisplayFilter` plugins -- see the
    /// comment on `RixDisplayChannel` above, regarding the multiplicity of some channel ids.
    ///
    /// \param[in] name Channel name.
    ///
    /// \return the first display channel with the provided name. Note: there could be other display
    /// channels using the same name.
    ///
    PRMAN_INLINE RixDisplayChannel const* GetDisplayChannel(RtUString name) const
    {
        for (int i = 0; i < numDisplays; ++i)
            if (displays[i].channel == name) return &displays[i];
        return nullptr;
    }

    /// Interface version.
    int m_version;

    // Some of the following quantities can be modified by the integrator on the object provided to
    // `RixIntegrator::RenderBegin()`.
    
    /// Integration state
    ///
    /// The maximum number of rays used for a 'bucket'. This is the maximum number of rays given to
    /// `RixIntegrator::IntegrateRays()`, or the maximum total number of points encapsulated in the
    /// shading contexts given to `RixIntegrator::Integrate()`.
    int maxIntegrateSize;
    /// The maximum number of points that a shading context will encapsulate. This affect all the
    /// shading contexts provided to the integrator by the renderer, including the ones returned by 
    /// the various `GetNearestHits()` and `GetTransmission()` methods.
    int           maxShadingCtxSize;
    /// Deprecated.
    SamplingModes supportedSamplingModes;
    /// Deprecated.
    LightingModes lightingRequirements;

    /// Display state (unmutable).
    int const                      numDisplays;
    RixDisplayChannel const* const displays;

    /// Increment state.
    ///
    /// Expresses whether integrator requires empty integrate request in adaptive rendering modes.
    bool wantsEmptyIntegrate;
    /// Expresses whether integrator requires all threads to synchronize on each rendering
    /// increment. This can impact performance; choose carefully whether this is really needed.
    /// See `k_RixSCIncrementBarrier`.
    bool wantsIncrementBarrier;  

    /// (unmutable).
    /// Total number of rays used per increment. This depends on the render resolution.
    int const numRaysPerIncrement;
    /// Total number of increments. This is usually `maxsamples`.
    int const numIncrements;

    /// Used to request iterations which do not contribute to the final result.
    int       numBootstrapIncrements;  

    /// Camera state.
    ///
    /// Used to establish state for the first "wavefront". Other calls to `GetNearestHit()` are
    /// parameterized as integrator chooses.
    RixBXLobeTraits lobesWanted;  
    /// If the camera is inside a non-trivial participating medium, this is the IOR of the medium.
    /// Defaults to 1.0f (air).
    float cameraMediumIOR;
    /// Priority of the medium surrounding the camera. Defaults to 0.
    int   cameraMediumPriority;
    /// Expresses whether integrator has a non trivial `GetTransmission()` method.
    bool  wantsTransmission;

    /// Indicates if the integrator will make use of `RixLightingServices`. If they are not used,
    /// some initialization in the renderer may be skipped. Defaults to true. 
    bool usesLightingServices;    
    char _reserved[30];
};

class RixIntegratorContext : public RixContext
{
public:
    /// This is the maximum number of rays per batch (i.e. nRays) allowed by the
    /// various `GetNearestHits()` and `GetTransmission()` methods.
    static constexpr int k_MaxRaysPerBatch = 32768;

    int integratorCtxId;  /// Unique identifier for integrator context.
    int numRays;          /// Size of the `primaryRays` array.
    /// May be less than `numRays` if the integrator sets `wantsEmptyIntegrate` and adaptive
    /// sampling is on. There will then be `numRays` rays in `primaryRays`, but only the first
    /// `numActiveRays` are considered still relevant by the adaptive sampler.
    int numActiveRays;  
    /// The primary camera rays.
    RtRayGeometry* primaryRays;
    /// A pointer to single RixRNG object, properly configured for `numRays` samples.
    RixRNG*        rngCtx;
    /// Shutter-normalized times associated with each ray. Array of size `numRays`. Values range
    /// from 0 (meaning shutter opening time) to 1 (meaning shutter closing time).
    float*         time;  

    virtual RixDisplayServices*             GetDisplayServices(int version = 1) const  = 0;
    virtual RixLightingServices*            GetLightingServices(int version = 1) const = 0;
    virtual RixVolumeServices*              GetVolumeServices(int version = 1) const   = 0;
    virtual RixRefCntPtr<RixLPE>            GetRixLPE(int version = 1) const           = 0;
    virtual RixIntegratorEnvironment const& GetEnv(int version = 1) const              = 0;

    enum NearestHitFlags
    {
        k_None                  = 0,
        k_Primary               = 1, ///< Indicate if the ray should be considered as a primary ray or a continuation of one, uninterrupted from the camera or a light source
        k_IncludeMisses         = 2, ///< Indicates if the caller wants the method to return 'empty' shading contexts for ray misses.
        k_ConstrainToVolume     = 4, ///< Indicates if the rays should not hit anything beyond the local volume.
        k_ContinuationOpacity   = 8, ///< Rays should continue as continuations through semi-opaque surfaces rather than stochastically terminating
        k_SkipVolumes           = 0x10  ///< Indicates if the rays should not hit any volumes.
    };

    /// This version of `GetNearestHits()` returns ray hits in
    /// the form of a list of `RixShadingContext`. These shading
    /// contexts represent a collection of points which have had their
    /// associated Bxdfs fully executed and set up for sample
    /// evaluation and generation. Since a Bxdf evaluation may trigger
    /// an upstream evaluation of all input patterns, this version of
    /// the call is considered to be very expensive as it invokes full
    /// shading.
    ///
    /// \param[in] nRays Number of rays to trace.
    /// Cannot be larger than RixIntegratorContext::k_MaxRaysPerBatch.
    ///
    /// \param[in] rays The rays to trace. Array of size `nRays`.
    ///
    /// \param[in] lobesWanted The `lobesWanted` that will be given to
    /// `RixBxdf::BeginScatter()` when setting up the bxdf for the ray
    /// hits.
    ///
    /// \param[in] rayType The type of the ray that should be
    /// fired. Primarily used for visibility testing of the geometry.
    ///
    /// \param[in] nearestHitFlags
    ///
    /// \param[in] subset The method will only yield hits on objects
    /// whose group membership matches `subset`.
    ///
    /// \param[in] excludeSubset The method will ignore hits on
    /// objects whose group membership matches `excludeSubset`.
    ///
    /// \param[in] hitSides The method will only yields hits on the
    /// indicated side of objects.
    ///
    /// \param[out] numShadingCtxs Number of shading contexts
    /// effectively returned in `shadingCtxs`.
    ///
    /// \param[out] shadingCtxs A pointer to an array of size at least
    /// 'nRays' (since it is possible each ray hit will yield a unique
    /// shading context).
    virtual void GetNearestHits(
        int nRays,
        RtRayGeometry const* rays,
        RixBXLobeTraits const& lobesWanted,
        RtRayGeometry::RayType rayType,
        int nearestHitFlags,
        RtUString const subset,
        RtUString const excludeSubset,
        RtHitSides hitSides,
        int* numShadingCtxs,
        RixShadingContext const** shadingCtxs) = 0;

    /// This version of `GetNearestHits()` returns ray hits in the
    /// form of a list of `RtHitGeometry`. No shading contexts are set
    /// up in this routine, and only information about the geometric
    /// locale is returned. This version of the call is preferred if
    /// no shading needs to be performed, such as in the case of an
    /// occlusion-only integrator.
    ///
    /// \param[in] nRays Number of rays to trace.
    /// Cannot be larger than RixIntegratorContext::k_MaxRaysPerBatch.
    ///
    /// \param[in] rays The rays to trace. Array of size `nRays`.
    ///
    /// \param[in] rayType The type of the ray that should be
    /// fired. Primarily used for visibility testing of the geometry.
    ///
    /// \param[in] nearestHitFlags
    ///
    /// \param[in] subset The method will only yield hits on objects
    /// whose group membership matches `subset`.
    ///
    /// \param[in] excludeSubset The method will ignore hits on
    /// objects whose group membership matches `excludeSubset`.
    ///
    /// \param[in] hitSides The method will only yields hits on the
    /// indicated side of objects.
    ///
    /// \param[out] hits Resulting ray hits from tracing rays.
    virtual void GetNearestHits(
        int nRays,
        RtRayGeometry const* rays,
        RtRayGeometry::RayType rayType,
        int nearestHitFlags,
        RtUString const subset,
        RtUString const excludeSubset,
        RtHitSides hitSides,
        RtHitPoint* hits) = 0;

    /// \deprecated This version of `GetNearestHits()` returns ray
    /// hits in the form of a list of `RixShadingContext`. These
    /// shading contexts represent a collection of points which have
    /// had their associated Bxdfs fully executed and set up for
    /// sample evaluation and generation. Since a Bxdf evaluation may
    /// trigger an upstream evaluation of all input patterns, this
    /// version of the call is considered to be very expensive as it
    /// invokes full shading.
    ///
    /// \param[in] nRays Number of rays to trace.
    /// Cannot be larger than RixIntegratorContext::k_MaxRaysPerBatch.
    ///
    /// \param[in] rays The rays to trace. Array of size `nRays`.
    ///
    /// \param[in] lobesWanted The `lobesWanted` that will be given to `RixBxdf::BeginScatter()` when
    /// setting up the bxdf for the ray hits. 
    ///
    /// \param[in] wantsMisses Indicates if the caller wants the method to return 'empty' shading
    /// contexts for ray misses.
    ///
    /// \param[out] numShadingCtxs Number of shading contexts effectively returned in `shadingCtxs`.
    ///
    /// \param[out] shadingCtxs A pointer to an array of size at least 'nRays' (since it is
    /// possible each ray hit will yield a unique shading context).
    ///
    /// \param[in] subset The method will only yield hits on objects whose group membership matches
    /// `subset`. Optional.
    ///
    /// \param[in] excludeSubset The method will ignore hits on objects whose group membership matches
    /// `excludeSubset`. Optional.
    ///
    /// \param[in] isLightPath Indicates if the rays are associated with a light path. Optional.
    ///
    /// \param[in] hitSides The method will only yields hits on the indicated side of objects.
    /// Optional.
    ///
    /// \param[in] isPrimary Indicate if the ray should be considered
    /// as a primary ray or a continuation of one, uninterrupted from
    /// the camera or a light source
    ///
    /// \param[in] isVolume Indicates if the rays should not hit anything beyond the local volume. Optional
    ///
    /// \param[in] stochasticMode Optional.
    virtual void GetNearestHits(
        int                       nRays,
        RtRayGeometry const*      rays,
        RixBXLobeTraits const&    lobesWanted,
        bool                      wantsMisses,
        int*                      numShadingCtxs,
        RixShadingContext const** shadingCtxs,
        // optional inputs:
        RtUString const subset         = US_NULL,
        RtUString const excludeSubset  = US_NULL,
        bool            isLightPath    = false,
        RtHitSides      hitSides       = k_SidesBoth,
        bool            isPrimary      = false,
        bool            isVolume       = false,
        bool            stochasticMode = true)
    {
        int nearestHitFlags =
            (isPrimary ? k_Primary : k_None) |            
            (wantsMisses ? k_IncludeMisses : k_None) |
            (isVolume ? k_ConstrainToVolume : k_None) |
            (stochasticMode ? k_None : k_ContinuationOpacity);
        RtRayGeometry::RayType raytype =
            (isLightPath ? RtRayGeometry::k_rtLight :
                (isPrimary ? RtRayGeometry::k_rtCamera : RtRayGeometry::k_rtIndirect));
        GetNearestHits(nRays, rays, lobesWanted,
            raytype, nearestHitFlags, subset, excludeSubset, hitSides, numShadingCtxs, shadingCtxs);
    }

    /// \deprecated This second version of `GetNearestHits()` returns
    /// ray hits in the form of a list of `RtHitGeometry`. No shading
    /// contexts are set up in this routine, and only information
    /// about the geometric locale is returned. This version of the
    /// call is preferred if no shading needs to be performed, such as
    /// in the case of an occlusion-only integrator.
    virtual void GetNearestHits(
        int                  nRays,
        RtRayGeometry const* rays,
        RtHitPoint*          hits,
        // optional inputs:
        RtUString const subset         = US_NULL,
        RtUString const excludeSubset  = US_NULL,
        RtHitSides      hitSides       = k_SidesBoth,
        bool            isPrimary      = false,
        bool            isVolume       = false,
        bool            stochasticMode = true)
    {
        int nearestHitFlags =
            (isPrimary ? k_Primary : k_None) |
            (isVolume ? k_ConstrainToVolume : k_None) |
            (stochasticMode ? k_None : k_ContinuationOpacity);
        RtRayGeometry::RayType raytype = (isPrimary ? RtRayGeometry::k_rtCamera : RtRayGeometry::k_rtIndirect);
        GetNearestHits(nRays, rays, raytype,
            nearestHitFlags, subset, excludeSubset, hitSides, hits);
    }

    /// `GetTransmission()` can be invoked by an integrator to compute the transmittance between two
    /// points in space. This is of use for bidirectional path tracing algorithms where the
    /// transmittance between vertex connections needs to be computed. It may also be used for
    /// computing shadow rays if the lighting services cannot be used for this purpose for some
    /// reason.
    /// 
    /// `RixLightingServices` are able to deal with transmission rays associated with direct
    /// lighting samples (if required) so simple unidirectional path tracers may have no need for
    /// this call. 
    ///
    /// The `isVolume` flag can be optionally set by a volume integrator to constrain the results to
    /// the bounds of a volume.
    ///
    /// \param[in] nRays Number of rays to trace.
    /// Cannot be larger than RixIntegratorContext::k_MaxRaysPerBatch.
    ///
    /// \param[in] rays The rays to trace. Array of size `nRays`.
    ///
    /// \param[out] transmissions Transmission between each ray origin and corresponding hit point.
    ///
    /// \param[out] volumeEmissions Emission due to participating media between each ray origin and
    /// corresponding hit point.
    ///
    virtual void GetTransmission(
        int                  nRays,
        RtRayGeometry const* rays,
        RtColorRGB*          transmissions,
        RtColorRGB*          volumeEmissions,
        // optional input:
        RtUString const subset        = US_NULL,
        RtUString const excludeSubset = US_NULL) = 0;

    /// This second version of `GetTransmission()` also returns:
    /// - forward distance sampling pdf,
    /// - reverse distance sampling pdf, 
    /// - probability of sampling distance larger than given distance (beyondPdf).
    ///
    /// \param[in] endsInVolume Indicates if each ray ends in volume or not, in order to properly
    /// compute pdfs.
    ///
    /// \param[out] volumeForwardPdfs Forward distance sampling pdf.
    ///
    /// \param[out] volumeReversePdfs Reverse distance sampling pdf.
    ///
    /// \param[out] volumeBeyondPdfs Probability of sampling a larger distance than the sampled
    /// one.
    ///
    virtual void GetTransmissionAndPdfs(
        int                  nRays,
        RtRayGeometry const* rays,
        bool const*          endsInVolume,
        RtColorRGB*          transmissions,
        RtColorRGB*          volumeEmissions,
        float*               volumeForwardPdfs,
        float*               volumeReversePdfs,
        float*               volumeBeyondPdfs,
        // optional input:
        RtUString const subset        = US_NULL,
        RtUString const excludeSubset = US_NULL) = 0;

    /// `ReleaseShadingContexts()` must be called to release the shading contexts created via
    /// `GetNearestHits()`. Shading contexts should not be released until after rays that originate
    /// from them have been traced.
    ///
    /// \param[in] numShadingCtxs Number of shading contexts.
    ///
    /// \param[in] shadingCtxs A pointer to an array of size 'numShadingCtxs'.
    ///
    virtual void ReleaseShadingContexts(
        int numShadingCtxs, RixShadingContext const** shadingCtxs) = 0;

    /// `Allocate()` and `New()` are utility (fully inlined and templated) methods to assist with
    /// memory management tasks associated with the memory pool of the `RixIntegratorContext`. Use
    /// `Allocate()` for raw allocations, `New()` for allocations with default construction.
    ///
    /// Usage: RtColorRGB *result = iCtx->Allocate<RtColorRGB>(100);
    enum MemCategory
    {
        k_IntegratorMem
    };
    virtual void* Allocate(size_t nObjs, size_t objSize, MemCategory) = 0;

    // contexts for ray misses
    template <class T> T* Allocate(size_t nObjs)
    {
        T* mem = static_cast<T*>(Allocate(nObjs, sizeof(T), k_IntegratorMem));
        return mem;
    }

    template <class T> T* New(size_t nObjs)
    {
        T* mem = static_cast<T*>(Allocate(nObjs, sizeof(T), k_IntegratorMem));
        return new (mem) T[nObjs];
    }

protected:
    virtual ~RixIntegratorContext() {}

public:
};

class RixIntegrator : public RixShadingPlugin
{
public:
    /// `RenderBegin()` and RenderEnd()` bound a rendering session. They are called in the primary
    /// thread.
    /// 
    /// \param[in] rCtx Allows the integrator to retrieve various `RixInterfaces`.
    ///
    /// \param[in,out] rixIntegratorEnv Allows the integrator to introspect the rendering environment.
    /// Additionally, allows the integrator to communicate some requirements back to the renderer.
    ///
    /// \param rixParameterList User provided integrator parameters.
    ///
    virtual void RenderBegin(
        RixContext&               rCtx,
        RixIntegratorEnvironment& rixIntegratorEnv,
        RixParameterList const*   rixParameterList) = 0;
    virtual void RenderEnd(RixContext& ctx)         = 0;

    /// `Synchronize()` is used to occasionally deliver status information from the renderer. The
    /// contents of `rixParameterList` depend upon the `rixSCSyncMessage` value.
    ///
    /// During rerendering, the parameter list may contain updated integrator parameter values. 
    /// Increment messages may deliver details about the increment in the parameter list.
    ///
    /// This method is optional and the default implementation ignores all events.
    virtual void Synchronize(
        RixContext&             rCtx,
        RixSCSyncMsg            rixSCSyncMsg,
        RixParameterList const* rixParameterList) override
    {
        PIXAR_ARGUSED(rCtx);
        PIXAR_ARGUSED(rixSCSyncMsg);
        PIXAR_ARGUSED(rixParameterList);
    }

    /// `IntegrateRays()` is the primary entry point for this class. This routine is expected to
    /// trace the list of primary rays delivered through the `RixIntegratorContext`.
    /// The default implementation simply calls `GetNearestHits()` to trace those primary rays, and
    /// passes the results to `Integrate()`, which is the secondary entry point for this class.
    ///
    /// \param[in] lobesWanted Provides a restriction on the lobes that should be considered when
    /// computing shading on the primary ray hits. Single value used for all primary rays.
    ///
    /// \param[out] numShadingCtxs Number of shading contexts effectively returned in `shadingCtxs`,
    /// resulting from tracing the primary rays. Generally, this will come directly from the call 
    /// to `GetNearestHits()`.
    ///
    /// \param[out] shadingCtxs A pointer to an array of size at least 'iCtx.numRays' (since it is
    /// possible each ray hit will yield its own shading context).
    ///
    /// \param[in] iCtx The `RixIntegratorContext` containing the primary rays to be processed.
    ///
    virtual void IntegrateRays(
        RixBXLobeTraits const&    lobesWanted,
        int*                      numShadingCtxs,
        RixShadingContext const** shadingCtxs,
        RixIntegratorContext&     iCtx)
    {
        if (iCtx.numActiveRays)
        {
            iCtx.GetNearestHits(
                iCtx.numActiveRays,
                iCtx.primaryRays,
                lobesWanted,
                RtRayGeometry::k_rtCamera,
                RixIntegratorContext::k_Primary,
                US_NULL, /*subset*/
                US_NULL, /*excludeSubset*/
                k_SidesFront,
                numShadingCtxs,
                shadingCtxs);
            RixDisplayServices* displayServices = iCtx.GetDisplayServices();
            for (int i = 0; i < *numShadingCtxs; ++i)
            {
                RixShadingContext const* sCtx = shadingCtxs[i];
                RtFloat const*           VLen;
                sCtx->GetBuiltinVar(RixShadingContext::k_VLen, &VLen);
                for (int j = 0; j < sCtx->numPts; ++j)
                {
                    int ctxIdx = sCtx->integratorCtxIndex[j];
                    displayServices->WriteDistance(ctxIdx, VLen[j], false);
                }
            }
            Integrate(*numShadingCtxs, shadingCtxs, iCtx);
        }
    }

    /// `Integrate()` is a secondary entry point for this class. The shading contexts passed to this
    /// routine are shading contexts resulting from tracing primary rays (usually by the default
    /// implementation of `IntegrateRays()`, but may potentially come via some other rendering
    /// technique). 
    /// Integrators are required to splat the radiance (corresponding to each primary ray) to the
    /// screen by using the `RixDisplayServices`.
    /// 
    ///
    /// \param[in] numShadingCtxs Number of shading contexts.
    ///
    /// \param[in] shadingCtxs A pointer to an array of size 'numShadingCtxs'.
    ///
    /// \param[in] iCtx The `RixIntegratorContext` containing the primary rays to be processed.
    ///
    virtual void Integrate(
        int numShadingCtxs, RixShadingContext const* shadingCtxs[], RixIntegratorContext& iCtx) = 0;

    /// The `GetTransmission()` method will only be called if the integrator has set the
    /// `wantsTransmission` field to true in the `RixIntegratorEnvironment` object given to
    /// `RenderBegin()`.
    ///
    /// This method is called by the renderer for transmission rays that have not already been
    /// considered fully opaque, and allows the integrator to account for other sources of
    /// transmission that may not be otherwise known to the renderer. 
    /// The default implementation does nothing.
    /// 
    /// Its parameters mirror the ones from `RixIntegratorContext::GetTransmission()`, with the
    /// following exception:
    /// \param[in,out] transmissions Contains the ray transmissions from sources already known to
    /// the renderer. Must return the ray transmissions from additional sources.
    virtual void GetTransmission(
        int                   nRays,
        RtRayGeometry const*  rays,
        RtColorRGB*           transmissions,
        RtColorRGB*           volumeEmissions,
        RtUString const       subset,
        RtUString const       excludeSubset,
        RixIntegratorContext& iCtx)
    {
        PIXAR_ARGUSED(nRays);
        PIXAR_ARGUSED(rays);
        PIXAR_ARGUSED(transmissions);
        PIXAR_ARGUSED(volumeEmissions);
        PIXAR_ARGUSED(subset);
        PIXAR_ARGUSED(excludeSubset);
        PIXAR_ARGUSED(iCtx);
    }

    /// Allows for retrieving ray properties. The integrator is expected to fill in the appropriate
    /// values.
    ///
    /// The caller of `GetProperty()` is responsible for allocating memory for the results. The
    /// `results` array needs to be of size `nRays` and of appropriate size for the type
    /// associated with the required property. 
    /// Caller should check the return value as it indicates whether or not valid results are
    /// obtained.
    ///
    /// \param[in] iCtx The `RixIntegratorContext` containing the primary rays to be processed.
    ///
    /// \param[in] rayIds Ray ids. Array of size `nRays`.
    ///
    /// \param[in] nRays Number of rays for which the property is queried.
    ///
    /// \param[in] rayProperty Ray property being retrieved.
    ///
    /// \param[out] results Array of size `nRays` in which to write the ray property values.
    ///
    virtual bool GetProperty(
        RixIntegratorContext& iCtx,
        const int*            rayIds,
        int                   nRays,
        RayProperty           rayProperty,
        void const*           results)
    {
        PIXAR_ARGUSED(iCtx);
        PIXAR_ARGUSED(rayIds);
        PIXAR_ARGUSED(nRays);
        PIXAR_ARGUSED(rayProperty);
        PIXAR_ARGUSED(results);

        return false;
    }

    /// Allows for retrieving ray properties. The integrator is expected to fill in the appropriate
    /// values.
    ///
    /// The caller of `SetProperty()` is responsible for allocating memory for the results (which
    /// means it needs to be aware of the data type associated with the given property). Caller
    /// should check the return value as it indicates whether or not valid results are obtained.
    ///
    /// The caller of `GetProperty()` is responsible for allocating memory for the results. The
    /// `values` array needs to be of size `nRays` and of appropriate size for the type associated
    /// with the required property. 
    /// Caller should check the return value as it indicates whether or not the property has been 
    /// properly set.
    ///
    /// \param[in] iCtx The `RixIntegratorContext` containing the primary rays to be processed.
    ///
    /// \param[in] rayIds Ray ids. Array of size `nRays`.
    ///
    /// \param[in] nRays Number of rays for which the property is queried.
    ///
    /// \param[in] rayProperty Ray property being retrieved.
    ///
    /// \param[in] values Array of size `nRays` containing the ray property values.
    ///
    virtual bool SetProperty(
        RixIntegratorContext& iCtx,
        const int*            rayIds,
        int                   nRays,
        RayProperty           rayProperty,
        void const*           values)
    {
        PIXAR_ARGUSED(iCtx);
        PIXAR_ARGUSED(rayIds);
        PIXAR_ARGUSED(nRays);
        PIXAR_ARGUSED(rayProperty);
        PIXAR_ARGUSED(values);

        return false;
    }

protected:
    RixIntegrator() : RixShadingPlugin(k_RixShadingVersion) {}
    virtual ~RixIntegrator() {}
};

#define RIX_INTEGRATORCREATE \
    extern "C" PRMANEXPORT RixIntegrator* CreateRixIntegrator(const char* hint)

#define RIX_INTEGRATORDESTROY \
    extern "C" PRMANEXPORT void DestroyRixIntegrator(RixIntegrator* integrator)

#endif
